---
title: "BMEF R Package"
output: rmarkdown::github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, fig.width = 6, fig.height = 5)
```

# BMEF: Bayesian Mixed-Effects Model for Two-Way Functional Data

The **BMEF** package implements Bayesian mixed-effects models for multilevel two-way functional data, with tools for posterior inference, rank selection, and visualization of time-frequency structure.

---

## Installation

---

## Simulate Data and Fit the Model

```{r simulate-and-fit, eval=FALSE}
library(BMEF)
library(pracma)
library(splines)

# Simulation setup
n <- 30       # number of subjects
J <- 3        # number of conditions
TT <- 50      # time points
FF <- 50      # frequency points
K_T <- 4      # time basis functions
K_F <- 5      # frequency basis functions
R <- 2        # true rank
p <- 2        # number of covariates

set.seed(123)
U <- randortho(K_T)[, 1:R]
V <- randortho(K_F)[, 1:R]
X <- cbind(1, runif(n, -3, 3))

Sigma2s <- list(
  Sigma2_epsilon = 0.1^2,
  Sigma2_gamma = 0.1^2,
  Sigma2_omega = runif(n, 0.2^2)
)

Delta <- array(runif(J * R * p, 0.5, 1), dim = c(J, R, p)) 
entries_idx <- rbinom(J * R * p, 1, 0.5)
Delta[entries_idx] <- -Delta[entries_idx]

# Generate synthetic data
dat <- dat.gen(seed = 1, n, J, TT, FF, K_T, K_F, U, V, Delta, X, Sigma2s)

# Fit BMEF models
n_burn <- 300
n_sample <- 200
tt <- dat$tt
ff <- dat$ff
Y <- dat$Y
JJ <- matrix(1, n, J)
R_max <- 4

bmef_1 <- bmef(Y, X, JJ, tt, ff, R = R_max, K_T, K_F, n_burn, n_sample,
               params = NULL, alg_type = "BMEF-1", threshold = 0.01, save_all = FALSE)

bmef_2 <- bmef(Y, X, JJ, tt, ff, R = R_max, K_T, K_F, n_burn, n_sample,
               params = NULL, alg_type = "BMEF-2", threshold = 0.01, save_all = FALSE)
```

---

## Posterior Inference

```{r inference, eval=FALSE}
# Posterior inference on fixed and random effects
bmef_obj <- bmef_1
cred_level <- 0.95

res_infer_decompose <- inference.decompose.bmef(bmef_obj, cred_level)
res_infer_mixed <- inference.mixed.bmef(bmef_obj)
```

---

## Visualization

```{r visualize, eval=FALSE}
library(tidyr)
library(ggplot2)

subject_idx <- 1  # subject index to make inference of
condition_idx <- 1  # condition index to make inference of

grid <- expand.grid(tt = tt, ff = ff)
grid$A_est <- c(res_infer_mixed$A_s[subject_idx, condition_idx,,])
grid$A_true<-dat$O_tilde%*%c(dat$A[subject_idx, condition_idx,,])

grid$B_est <- c(res_infer_mixed$B_s[subject_idx, ,])
grid$B_true<-dat$O_tilde%*%c(dat$B[subject_idx, ,])

grid$C_est <- c(res_infer_mixed$C_s[subject_idx, condition_idx,,])
grid$C_true<-dat$O_tilde%*%c(dat$C[subject_idx, condition_idx,,])

df_long <- pivot_longer(grid, 
                          cols = c("A_est", "A_true",
                                   "B_est", "B_true",
                                   "C_est", "C_true"), 
                          names_to = "type") 
colnames(df_long)[4] <- "value"

# compare estimated A with true A
p_A <- ggplot(df_long %>%dplyr::filter(type %in% c("A_est", "A_true")), aes(x = tt, y = ff, fill = value)) +
  geom_tile() +
  scale_fill_viridis_c() +  # Heatmap color scale
  facet_wrap(~type,nrow = 1) + 
  labs(x = "Time",
       y = "Frequency",
       fill = "Value") +    theme(panel.background = element_blank(),
                                  plot.background = element_blank(),
                                  panel.grid.major.x = element_blank(),   
                                  panel.grid.minor.x = element_blank()
       )  +  theme(strip.text = element_text(size = 12, face = "bold"))


# compare estimated B with true B
p_B <- ggplot(df_long %>%dplyr::filter(type %in% c("B_est", "B_true")), aes(x = tt, y = ff, fill = value)) +
  geom_tile() +
  scale_fill_viridis_c() +  # Heatmap color scale
  facet_wrap(~type,nrow = 1) + 
  labs(x = "Time",
       y = "Frequency",
       fill = "Value") +    theme(panel.background = element_blank(),
                                  plot.background = element_blank(),
                                  panel.grid.major.x = element_blank(),   
                                  panel.grid.minor.x = element_blank()
       )  +  theme(strip.text = element_text(size = 12, face = "bold"))
  
# compare estimated C with true C
p_C <- ggplot(df_long %>%dplyr::filter(type %in% c("C_est", "C_true")), aes(x = tt, y = ff, fill = value)) +
  geom_tile() +
  scale_fill_viridis_c() +  # Heatmap color scale
  facet_wrap(~type,nrow = 1) + 
  labs(x = "Time",
       y = "Frequency",
       fill = "Value") +    theme(panel.background = element_blank(),
                                  plot.background = element_blank(),
                                  panel.grid.major.x = element_blank(),   
                                  panel.grid.minor.x = element_blank()
       )  +  theme(strip.text = element_text(size = 12, face = "bold"))
  

```

---

## Make inference of the two-way "base" patterns and marginal "principal" functions

```{r base-patterns, eval=FALSE}

Rs <- 
p1 <- ggplot(dat2plot[dat2plot$rank == "Rank 1",], aes(x = tt, y = ff, fill = value)) +
  geom_tile() +
  scale_fill_viridis_c() +  # Heatmap color scale
  facet_wrap(~rank,nrow = 1) + 
  labs(x = "t (Sec)",
       y = "f (Hz)",
       fill = " ") +    theme(panel.background = element_blank(),
                              plot.background = element_blank(),
                              panel.grid.major.x = element_blank(),   
                              panel.grid.minor.x = element_blank()
       ) +theme(legend.position  = "left") +  theme(strip.text = element_text(size = 14, face = "bold"))
p2 <- ggplot(dat2plot[dat2plot$rank == "Rank 2",], aes(x = tt, y = ff, fill = value)) +
  geom_tile() +
  scale_fill_viridis_c( labels = number_format(accuracy = 0.04)) +  # Heatmap color scale
  facet_wrap(~rank,nrow = 1) + 
  labs(x = "t (Sec)",
       y = "f (Hz)",
       fill = "") +    theme(panel.background = element_blank(),
                             plot.background = element_blank(),
                             panel.grid.major.x = element_blank(),   
                             panel.grid.minor.x = element_blank()
       ) + theme(legend.position  = "left") +  theme(strip.text = element_text(size = 14, face = "bold"))

## need credible intervals
pt_list <- list()
pf_list <- list()

for(r in 1:R){
  data_t <- data.frame(
    x = tt,
    mean = apply(bsMat_tt%*%C_t%*%t(tensor_model$u_s[sample_idx,r, ]), 1, mean),
    lower_95 = apply(bsMat_tt%*%C_t%*%t(tensor_model$u_s[sample_idx,r, ]), 1, function(u){quantile(u, 0.025)}),
    upper_95 = apply(bsMat_tt%*%C_t%*%t(tensor_model$u_s[sample_idx,r, ]), 1, function(u){quantile(u, 0.975)})
  )
  data_f <- data.frame(
    x = ff*1000,
    mean = apply(bsMat_ff%*%C_f%*%t(tensor_model$v_s[sample_idx,r, ]), 1, mean),
    lower_95 = apply(bsMat_ff%*%C_f%*%t(tensor_model$v_s[sample_idx,r, ]), 1, function(u){quantile(u, 0.025)}),
    upper_95 = apply(bsMat_ff%*%C_f%*%t(tensor_model$v_s[sample_idx,r, ]), 1, function(u){quantile(u, 0.975)})
  )
  
  if(r==1){
    
    data_t$mean <- - data_t$mean
    data_t$lower_95 <- - data_t$lower_95

    data_t$upper_95 <- - data_t$upper_95

    pt_list[[r]] = ggplot(data_t, aes(x = x)) +
      geom_ribbon(aes(ymin = lower_95, ymax = upper_95), fill = "gray60", alpha = 0.5) +  # 
      geom_line(aes(y = mean), color = "black", size = 0.6) +  
      labs(y = expression(phi[1]^"*"~"(t)"),
           x = "t (Sec)")
    pf_list[[r]] = ggplot(data_f, aes(x = x)) +
      geom_ribbon(aes(ymin = lower_95, ymax = upper_95), fill = "gray60", alpha = 0.5) +  # 
      geom_line(aes(y = mean), color = "black", size = 0.6) + 
      labs(y = expression(psi[1]^"*"~"(f)"),
           x = "f (Hz)")
  }
}


for(r in 1:R){
  pf_list[[r]] =  pf_list[[r]] + theme_minimal() + theme(
    panel.grid = element_blank(),   
    axis.line = element_line(color = "black"),  
    axis.ticks = element_blank(),  
    axis.text = element_text(size = 12, face = "bold"),  
    plot.title = element_text(size = 14, face = "bold"),
    axis.title.x = element_text(size = 16), 
    axis.title.y = element_text(size = 16) 
  )   + theme(plot.margin = margin(40, 10, 10, 10))
  pt_list[[r]] =  pt_list[[r]] + theme_minimal() + theme(
    panel.grid = element_blank(),  
    axis.line = element_line(color = "black"), 
    axis.ticks = element_blank(),  
    axis.text = element_text(size = 12, face = "bold"), 
    plot.title = element_text(size = 14, face = "bold"),
    axis.title.x = element_text(size = 16), 
    axis.title.y = element_text(size = 16) 
  )   + theme(plot.margin = margin(40, 10, 10, 10))
  
}






for(r in R_indices){
  dat2plot <- NULL
  for(j in 1:J){
    tmp <-  data.frame(cbind(tensor_model$delta_s[sample_idx,j,r, 1], tensor_model$delta_s[sample_idx,j,r, 1]+ tensor_model$delta_s[sample_idx,j,r, 2]))
    lower <- apply(tmp, 2, function(u){quantile(u, 0.025)})*2  # recover scale
    upper <- apply(tmp, 2, function(u){quantile(u, 0.925)})*2  # recover scale
    mid <- apply(tmp, 2, median)*2
    if(r == 1){
      lower <- - lower
      upper <- -upper
      mid <- -mid
    }
    tmp <- data.frame(cbind(lower, upper,mid,  c("Control", "Alcohol"), rep(c("C1", "C2", "C3")[j], 2)))
    dat2plot <- rbind(dat2plot, tmp)
  }
  colnames(dat2plot) <- c("lower","upper","mid", "group", "condition")
  
  dat2plot$lower  <- as.numeric(dat2plot$lower) 
  dat2plot$upper  <- as.numeric(dat2plot$upper) 
  dat2plot$mid <- as.numeric(dat2plot$mid) 
  
  
  rr <- which(R_indices == r)
  pp_list[[rr]] = ggplot(dat2plot, aes( y = condition, x = mid, color = group)) +
    geom_point(position = position_dodge(width = 0.5), size = 3) +
    geom_errorbar(aes(xmin = lower, xmax = upper),  position = position_dodge(width = 0.5)) +
    theme_minimal() + #scale_y_continuous(limits = c(-11, 10)) +
    labs(x = "weight") +  
    theme(
      legend.position = c(1, 1.1), 
      legend.title = element_blank(),
      legend.justification = c(1, 1),  # Align legend inside the plot
      legend.direction = "horizontal",  # Make legend horizontal
      legend.text = element_text(size = 10, face = "bold"),  # Make legend text smaller
      panel.grid = element_blank(),  # Remove all grid lines
      axis.line = element_line(color = "black"),  # Keep x and y axis lines
      axis.text = element_text(size = 16),  # Adjust text size
      axis.title = element_text(size = 16),
      plot.title = element_text(size = 14, face = "bold")) + theme(plot.margin = margin(40, 10, 10, 10)) 
}









```
